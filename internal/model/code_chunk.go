package model

import (
	"bot-go/pkg/lsp/base"
)

// ChunkType represents the hierarchical level of a code chunk
type ChunkType string

const (
	ChunkTypeFile        ChunkType = "file"
	ChunkTypeClass       ChunkType = "class"
	ChunkTypeFunction    ChunkType = "function"
	ChunkTypeBlock       ChunkType = "block"
	ChunkTypeConditional ChunkType = "conditional" // if, else, switch, case
	ChunkTypeLoop        ChunkType = "loop"        // for, while, do-while
)

// CodeChunk represents a hierarchical piece of code with vector embedding
type CodeChunk struct {
	// Unique identifier for this chunk
	ID string `json:"id"`

	// FileID from MySQL file_versions table (shared with CodeGraph)
	FileID int32 `json:"file_id"`

	// Hierarchical metadata
	ChunkType ChunkType `json:"chunk_type"`
	Level     int       `json:"level"` // 1=file, 2=class, 3=function, 4=block
	ParentID  string    `json:"parent_id,omitempty"`

	// Code content
	Content   string     `json:"content"`
	Language  string     `json:"language"`
	FilePath  string     `json:"file_path"`
	StartLine int        `json:"start_line"`
	EndLine   int        `json:"end_line"`
	Range     base.Range `json:"range"`

	// Semantic metadata
	Name      string `json:"name,omitempty"`      // Function/class/file name
	Signature string `json:"signature,omitempty"` // Function signature
	Docstring string `json:"docstring,omitempty"` // Documentation

	// Context for better understanding
	ModuleName string `json:"module_name,omitempty"` // Package/module name
	ClassName  string `json:"class_name,omitempty"`  // Parent class if method

	// Vector embedding (generated by embedding model)
	Embedding []float32 `json:"embedding,omitempty"`

	// Additional metadata
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// NewCodeChunk creates a new code chunk with basic information
func NewCodeChunk(id string, chunkType ChunkType, level int, content, language, filePath string, rng base.Range) *CodeChunk {
	return &CodeChunk{
		ID:        id,
		ChunkType: chunkType,
		Level:     level,
		Content:   content,
		Language:  language,
		FilePath:  filePath,
		Range:     rng,
		StartLine: rng.Start.Line,
		EndLine:   rng.End.Line,
		Metadata:  make(map[string]interface{}),
	}
}

// WithFileID sets the FileID from MySQL
func (c *CodeChunk) WithFileID(fileID int32) *CodeChunk {
	c.FileID = fileID
	return c
}

// WithParent sets the parent chunk ID
func (c *CodeChunk) WithParent(parentID string) *CodeChunk {
	c.ParentID = parentID
	return c
}

// WithName sets the name (function/class/module name)
func (c *CodeChunk) WithName(name string) *CodeChunk {
	c.Name = name
	return c
}

// WithSignature sets the function signature
func (c *CodeChunk) WithSignature(signature string) *CodeChunk {
	c.Signature = signature
	return c
}

// WithDocstring sets the documentation string
func (c *CodeChunk) WithDocstring(docstring string) *CodeChunk {
	c.Docstring = docstring
	return c
}

// WithContext sets the module and class context
func (c *CodeChunk) WithContext(moduleName, className string) *CodeChunk {
	c.ModuleName = moduleName
	c.ClassName = className
	return c
}

// WithEmbedding sets the vector embedding
func (c *CodeChunk) WithEmbedding(embedding []float32) *CodeChunk {
	c.Embedding = embedding
	return c
}

// WithMetadata adds custom metadata
func (c *CodeChunk) WithMetadata(key string, value interface{}) *CodeChunk {
	if c.Metadata == nil {
		c.Metadata = make(map[string]interface{})
	}
	c.Metadata[key] = value
	return c
}

// GetSearchableText returns the text representation for embedding generation
// Truncates content to avoid exceeding embedding model context limits
// includeContext: if true, includes module/class context; if false, only includes the code content
func (c *CodeChunk) GetSearchableText(includeContext bool) string {
	const maxChars = 8000 // Conservative limit for most embedding models (~2000 tokens)

	text := ""

	// Add context information only if requested
	if includeContext {
		if c.ModuleName != "" {
			text += "Module: " + c.ModuleName + "\n"
		}
		if c.ClassName != "" {
			text += "Class: " + c.ClassName + "\n"
		}

		// Add signature and docstring if available
		if c.Signature != "" {
			text += c.Signature + "\n"
		}
		if c.Docstring != "" {
			text += c.Docstring + "\n"
		}
	}

	// Add the actual code content (may be truncated)
	remainingChars := maxChars - len(text)
	if remainingChars > 0 {
		if len(c.Content) > remainingChars {
			// Truncate content and add indicator
			text += c.Content[:remainingChars-20] + "\n// ... (truncated)"
		} else {
			text += c.Content
		}
	}

	return text
}
