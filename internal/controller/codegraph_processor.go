package controller

import (
	"bot-go/internal/config"
	"bot-go/internal/parse"
	"bot-go/internal/service"
	"bot-go/internal/service/codegraph"
	"context"
	"os"

	"go.uber.org/zap"
)

// CodeGraphProcessor implements FileProcessor for code graph building
type CodeGraphProcessor struct {
	config      *config.Config
	codeGraph   *codegraph.CodeGraph
	repoService *service.RepoService
	logger      *zap.Logger
}

// NewCodeGraphProcessor creates a new code graph processor
func NewCodeGraphProcessor(
	config *config.Config,
	codeGraph *codegraph.CodeGraph,
	repoService *service.RepoService,
	logger *zap.Logger,
) *CodeGraphProcessor {
	return &CodeGraphProcessor{
		config:      config,
		codeGraph:   codeGraph,
		repoService: repoService,
		logger:      logger,
	}
}

// Name returns the processor name
func (cgp *CodeGraphProcessor) Name() string {
	return "CodeGraph"
}

// ProcessFile processes a single file for code graph building
func (cgp *CodeGraphProcessor) ProcessFile(ctx context.Context, repo *config.Repository, fileCtx *FileContext) error {
	fileParser := parse.NewFileParser(cgp.logger, cgp.codeGraph, cgp.config)

	// Use real file info so modification timestamps are accurate
	info, err := os.Stat(fileCtx.FilePath)
	if err != nil {
		cgp.logger.Error("Failed to stat file for code graph processing",
			zap.String("path", fileCtx.FilePath),
			zap.Error(err))
		return nil
	}

	if fileParser.ShouldSkipFile(ctx, repo, info, fileCtx.FilePath) {
		return nil
	}

	cgp.logger.Debug("Parsing file for code graph",
		zap.String("path", fileCtx.FilePath),
		zap.Int32("file_id", fileCtx.FileID),
		zap.String("sha", fileCtx.FileSHA),
		zap.Bool("ephemeral", fileCtx.Ephemeral))

	// Initialize buffers for this file before processing
	// This reduces lock contention during node/relation writes
	cgp.codeGraph.InitializeFileBuffers(fileCtx.FileID)

	// Use FileID from FileContext (already generated by IndexBuilder)
	version := int32(1) // Default version

	err = fileParser.ParseAndTraverseWithContent(ctx, repo, info, fileCtx.FilePath, fileCtx.FileID, version, fileCtx.Content)
	if err != nil {
		cgp.logger.Error("Failed to parse file for code graph",
			zap.String("path", fileCtx.FilePath),
			zap.Int32("file_id", fileCtx.FileID),
			zap.Error(err))
		// Still cleanup buffers even on error
		cgp.codeGraph.CleanupFileBuffers(ctx, fileCtx.FileID)
		return nil // Continue processing other files
	}

	// Cleanup: flush remaining data and remove buffers for this file
	// This ensures data is written to DB and memory is freed
	if err := cgp.codeGraph.CleanupFileBuffers(ctx, fileCtx.FileID); err != nil {
		cgp.logger.Error("Failed to cleanup code graph buffers after file processing",
			zap.String("path", fileCtx.FilePath),
			zap.Int32("file_id", fileCtx.FileID),
			zap.Error(err))
		return nil // Continue processing other files
	}

	cgp.logger.Debug("Successfully parsed file for code graph",
		zap.String("path", fileCtx.FilePath),
		zap.Int32("file_id", fileCtx.FileID))
	return nil
}

// PostProcess performs LSP-based post-processing on the repository
func (cgp *CodeGraphProcessor) PostProcess(ctx context.Context, repo *config.Repository) error {
	cgp.logger.Info("Running code graph post-processing", zap.String("repo_name", repo.Name))

	// Flush any remaining buffered nodes and relations before post-processing
	cgp.logger.Debug("Flushing all buffered nodes and relations before post-processing")
	if err := cgp.codeGraph.Flush(ctx, nil); err != nil {
		cgp.logger.Error("Failed to flush code graph buffers",
			zap.String("repo_name", repo.Name),
			zap.Error(err))
		return err
	}

	postProcessor := NewPostProcessor(cgp.codeGraph, cgp.repoService.GetLspService(), cgp.logger)
	err := postProcessor.PostProcessRepository(ctx, repo)
	if err != nil {
		cgp.logger.Error("Code graph post-processing failed",
			zap.String("repo_name", repo.Name),
			zap.Error(err))
		return err
	}

	// Flush again after post-processing (in case post-processor created new relations)
	cgp.logger.Debug("Flushing all code graph buffers after post-processing")
	if err := cgp.codeGraph.Flush(ctx, nil); err != nil {
		cgp.logger.Error("Failed to flush code graph buffers after post-processing",
			zap.String("repo_name", repo.Name),
			zap.Error(err))
		return err
	}

	cgp.logger.Info("Code graph post-processing completed", zap.String("repo_name", repo.Name))
	return nil
}
